{"version":3,"sources":["webpack:///./node_modules/socket.io-client/build/on.js","webpack:///./node_modules/socket.io-client/build/manager.js","webpack:///./node_modules/socket.io-client/build/socket.js","webpack:///./node_modules/socket.io-client/build/url.js","webpack:///./node_modules/socket.io-parser/dist/index.js","webpack:///./node_modules/socket.io-client/build/index.js","webpack:///./node_modules/socket.io-parser/dist/binary.js","webpack:///./node_modules/socket.io-parser/dist/is-binary.js"],"names":["on","obj","ev","fn","off","Object","defineProperty","exports","value","Manager","eio","socket_1","Emitter","parser","on_1","Backoff","debug","uri","opts","super","this","nsps","subs","undefined","path","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","min","max","jitter","timeout","_readyState","_parser","encoder","Encoder","decoder","Decoder","_autoConnect","autoConnect","open","v","arguments","length","_reconnection","_reconnectionAttempts","_a","_reconnectionDelay","setMin","_randomizationFactor","setJitter","_reconnectionDelayMax","setMax","_timeout","_reconnecting","attempts","reconnect","indexOf","engine","socket","self","skipReconnect","openSubDestroy","onopen","errorSub","err","cleanup","emit","maybeReconnectOnOpen","timer","setTimeout","close","Error","push","clearTimeout","onping","bind","ondata","onerror","onclose","ondecoded","data","add","packet","nsp","Socket","keys","active","_close","encodedPackets","encode","i","write","options","forEach","subDestroy","destroy","reset","reason","delay","duration","onreconnect","attempt","socket_io_parser_1","RESERVED_EVENTS","freeze","connect","connect_error","disconnect","disconnecting","newListener","removeListener","io","receiveBuffer","sendBuffer","ids","acks","flags","connected","disconnected","auth","onpacket","subEvents","args","unshift","apply","hasOwnProperty","type","PacketType","EVENT","compress","pop","id","isTransportWritable","transport","writable","discardPacket","volatile","_packet","CONNECT","sameNamespace","sid","onconnect","onevent","BINARY_EVENT","ACK","onack","BINARY_ACK","DISCONNECT","ondisconnect","CONNECT_ERROR","message","ack","emitEvent","_anyListeners","listeners","slice","listener","sent","emitBuffered","splice","url","parseuri","loc","location","protocol","host","charAt","test","port","ipv6","href","binary_1","is_binary_1","hasBinary","encodeAsString","encodeAsBinary","str","attachments","JSON","stringify","deconstruction","deconstructPacket","pack","buffers","decodeString","reconstructor","BinaryReconstructor","isBinary","base64","takeBinaryData","p","Number","start","buf","substring","c","next","payload","tryParse","substr","isPayloadValid","Array","isArray","finishedReconstruction","parse","e","reconPack","binData","reconstructPacket","url_1","manager_1","enumerable","get","module","lookup","cache","managers","parsed","source","newConnection","forceNew","multiplex","query","queryKey","manager_2","packetData","_deconstructPacket","placeholder","_placeholder","num","newData","Date","key","_reconstructPacket","withNativeArrayBuffer","ArrayBuffer","isView","buffer","toString","prototype","withNativeBlob","Blob","call","withNativeFile","File","toJSON","l"],"mappings":"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","file":"js/chunk-vendors~2eebe792.969f3f29.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.on = void 0;\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\nexports.on = on;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Manager = void 0;\nconst eio = require(\"engine.io-client\");\nconst socket_1 = require(\"./socket\");\nconst Emitter = require(\"component-emitter\");\nconst parser = require(\"socket.io-parser\");\nconst on_1 = require(\"./on\");\nconst Backoff = require(\"backo2\");\nconst debug = require(\"debug\")(\"socket.io-client:manager\");\nclass Manager extends Emitter {\n    constructor(uri, opts) {\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor(opts.randomizationFactor || 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        debug(\"readyState %s\", this._readyState);\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        debug(\"opening %s\", this.uri);\n        this.engine = eio(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on_1.on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = on_1.on(socket, \"error\", (err) => {\n            debug(\"error\");\n            self.cleanup();\n            self._readyState = \"closed\";\n            super.emit(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            debug(\"connect attempt will timeout after %d\", timeout);\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = setTimeout(() => {\n                debug(\"connect attempt timed out after %d\", timeout);\n                openSubDestroy();\n                socket.close();\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"open\");\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        super.emit(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on_1.on(socket, \"ping\", this.onping.bind(this)), on_1.on(socket, \"data\", this.ondata.bind(this)), on_1.on(socket, \"error\", this.onerror.bind(this)), on_1.on(socket, \"close\", this.onclose.bind(this)), on_1.on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        super.emit(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        this.decoder.add(data);\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        super.emit(\"packet\", packet);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        debug(\"error\", err);\n        super.emit(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new socket_1.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                debug(\"socket %s is still active, skipping close\", nsp);\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        debug(\"writing packet %j\", packet);\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        debug(\"cleanup\");\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        debug(\"disconnect\");\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        if (\"opening\" === this._readyState) {\n            // `onclose` will not fire because\n            // an open event never happened\n            this.cleanup();\n        }\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason) {\n        debug(\"onclose\");\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        super.emit(\"close\", reason);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            debug(\"reconnect failed\");\n            this.backoff.reset();\n            super.emit(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            debug(\"will wait %dms before reconnect attempt\", delay);\n            this._reconnecting = true;\n            const timer = setTimeout(() => {\n                if (self.skipReconnect)\n                    return;\n                debug(\"attempting reconnect\");\n                super.emit(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        debug(\"reconnect attempt error\");\n                        self._reconnecting = false;\n                        self.reconnect();\n                        super.emit(\"reconnect_error\", err);\n                    }\n                    else {\n                        debug(\"reconnect success\");\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        super.emit(\"reconnect\", attempt);\n    }\n}\nexports.Manager = Manager;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst Emitter = require(\"component-emitter\");\nconst on_1 = require(\"./on\");\nconst debug = require(\"debug\")(\"socket.io-client:socket\");\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\nclass Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     *\n     * @public\n     */\n    constructor(io, nsp, opts) {\n        super();\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        this.ids = 0;\n        this.acks = {};\n        this.receiveBuffer = [];\n        this.sendBuffer = [];\n        this.connected = false;\n        this.disconnected = true;\n        this.flags = {};\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on_1.on(io, \"open\", this.onopen.bind(this)),\n            on_1.on(io, \"packet\", this.onpacket.bind(this)),\n            on_1.on(io, \"error\", this.onerror.bind(this)),\n            on_1.on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @public\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for connect()\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * @return self\n     * @public\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @param ev - event name\n     * @return self\n     * @public\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            debug(\"emitting packet with ack id %d\", this.ids);\n            this.acks[this.ids] = args.pop();\n            packet.id = this.ids++;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n            debug(\"discard packet as the transport is not currently writable\");\n        }\n        else if (this.connected) {\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        debug(\"transport is open - connecting\");\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });\n            });\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });\n        }\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            super.emit(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        debug(\"close (%s)\", reason);\n        this.connected = false;\n        this.disconnected = true;\n        delete this.id;\n        super.emit(\"disconnect\", reason);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    const id = packet.data.sid;\n                    this.onconnect(id);\n                }\n                else {\n                    super.emit(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser_1.PacketType.CONNECT_ERROR:\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                super.emit(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            debug(\"sending ack %j\", args);\n            self.packet({\n                type: socket_io_parser_1.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id) {\n        debug(\"socket connected with id %s\", id);\n        this.id = id;\n        this.connected = true;\n        this.disconnected = false;\n        super.emit(\"connect\");\n        this.emitBuffered();\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => this.packet(packet));\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"server disconnect (%s)\", this.nsp);\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually.\n     *\n     * @return self\n     * @public\n     */\n    disconnect() {\n        if (this.connected) {\n            debug(\"performing disconnect (%s)\", this.nsp);\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for disconnect()\n     *\n     * @return self\n     * @public\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     * @public\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @returns self\n     * @public\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @param listener\n     * @public\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     * @public\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @param listener\n     * @public\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     *\n     * @public\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n}\nexports.Socket = Socket;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.url = void 0;\nconst parseuri = require(\"parseuri\");\nconst debug = require(\"debug\")(\"socket.io-client:url\");\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            debug(\"protocol-less url %s\", uri);\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        debug(\"parse %s\", uri);\n        obj = parseuri(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\nexports.url = url;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;\nconst Emitter = require(\"component-emitter\");\nconst binary_1 = require(\"./binary\");\nconst is_binary_1 = require(\"./is-binary\");\nconst debug = require(\"debug\")(\"socket.io-parser\");\n/**\n * Protocol version.\n *\n * @public\n */\nexports.protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        debug(\"encoding packet %j\", obj);\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (is_binary_1.hasBinary(obj)) {\n                obj.type =\n                    obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK;\n                return this.encodeAsBinary(obj);\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data);\n        }\n        debug(\"encoded %j as %s\", obj, str);\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = binary_1.deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\nexports.Encoder = Encoder;\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends Emitter {\n    constructor() {\n        super();\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            packet = this.decodeString(obj);\n            if (packet.type === PacketType.BINARY_EVENT ||\n                packet.type === PacketType.BINARY_ACK) {\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emit(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emit(\"decoded\", packet);\n            }\n        }\n        else if (is_binary_1.isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emit(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        debug(\"decoded %s as %j\", str, p);\n        return p;\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return Array.isArray(payload) && payload.length > 0;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n        }\n    }\n}\nexports.Decoder = Decoder;\nfunction tryParse(str) {\n    try {\n        return JSON.parse(str);\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = exports.io = exports.Manager = exports.protocol = void 0;\nconst url_1 = require(\"./url\");\nconst manager_1 = require(\"./manager\");\nconst socket_1 = require(\"./socket\");\nObject.defineProperty(exports, \"Socket\", { enumerable: true, get: function () { return socket_1.Socket; } });\nconst debug = require(\"debug\")(\"socket.io-client\");\n/**\n * Module exports.\n */\nmodule.exports = exports = lookup;\n/**\n * Managers cache.\n */\nconst cache = (exports.managers = {});\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url_1.url(uri, opts.path);\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        debug(\"ignoring socket cache for %s\", source);\n        io = new manager_1.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            debug(\"new io instance for %s\", source);\n            cache[id] = new manager_1.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\nexports.io = lookup;\n/**\n * Protocol version.\n *\n * @public\n */\nvar socket_io_parser_1 = require(\"socket.io-parser\");\nObject.defineProperty(exports, \"protocol\", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });\n/**\n * `connect`.\n *\n * @param {String} uri\n * @public\n */\nexports.connect = lookup;\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nvar manager_2 = require(\"./manager\");\nObject.defineProperty(exports, \"Manager\", { enumerable: true, get: function () { return manager_2.Manager; } });\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reconstructPacket = exports.deconstructPacket = void 0;\nconst is_binary_1 = require(\"./is-binary\");\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nexports.deconstructPacket = deconstructPacket;\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (is_binary_1.isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    packet.attachments = undefined; // no longer useful\n    return packet;\n}\nexports.reconstructPacket = reconstructPacket;\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder) {\n        return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (data.hasOwnProperty(key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasBinary = exports.isBinary = void 0;\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexports.isBinary = isBinary;\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasBinary = hasBinary;\n"],"sourceRoot":""}